# 100DaysOfSwiftUI

## Day1 

Simple Types
Variables
SCORE: 6/6
Strings and integers
SCORE: 6/6
Multi-line strings
SCORE: 12/12
Doubles and booleans
SCORE: 6/6
String interpolation
SCORE: 6/6
Constants
SCORE: 6/6
Type annotations
SCORE: 6/6
Simple types: Summary
SCORE: 6/6

## Day2


Complex Types
Arrays
SCORE: 6/6
Sets
SCORE: 12/12
Tuples
SCORE: 6/6
Arrays vs sets vs tuples
SCORE: 5/6
Dictionaries
SCORE: 6/6
Dictionary default values
SCORE: 8/12
Creating empty collections
SCORE: 6/6
Enumerations
SCORE: 6/6
Enum associated values
SCORE: 6/6
Enum raw values
SCORE: 6/6
Complex types: Summary
SCORE: 4/6


## Day3


Operators and conditions
Arithmetic operators
SCORE: 6/6
Operator overloading
SCORE: 12/12
Compound assignment operators
SCORE: 6/6
Comparison operators
SCORE: 6/6
Conditions
SCORE: 12/12
Combining conditions
SCORE: 12/12
The ternary operator
SCORE: 12/12
Switch statements
SCORE: 6/6
Range operators
SCORE: 5/6
Operators and conditions: Summary
SCORE: 9/12


## Day4


Looping
For loops
SCORE: 11/12
While loops
SCORE: 7/12
Repeat loops
SCORE: 9/12
Exiting loops
SCORE: 10/12
Exiting multiple loops
SCORE: 6/6
Skipping items
SCORE: 10/12
Infinite loops
SCORE: 11/12
Looping: Summary
SCORE: 10/12

## Day5


Functions
Writing functions
SCORE: 9/12
Accepting parameters
SCORE: 9/12
Returning values
SCORE: 8/12
Parameter labels
SCORE: 11/12
Omitting parameter labels
SCORE: 11/12
Default parameters
SCORE: 10/12
Variadic functions
SCORE: 5/6
Writing throwing functions
SCORE: 7/12
Running throwing functions
SCORE: 5/6
inout parameters
SCORE: 6/6
Functions: Summary
SCORE: 11/12

## Day6


Closures
Creating basic closures
SCORE: 9/12
Accepting parameters in a closure
SCORE: 11/12
Returning values from a closure
SCORE: 9/12
Closures as parameters
SCORE: 9/12
Trailing closure syntax
SCORE: 10/12

## Day7 

Using closures as parameters when they accept parameters
SCORE: 9/12
Using closures as parameters when they return values
SCORE: 8/12
Shorthand parameter names
SCORE: 6/6
Closures with multiple parameters
SCORE: 9/12
Returning closures from functions
SCORE: 11/12
Capturing values
SCORE: 8/12
Closures: Summary
SCORE: 5/6

## Day8

Structs
Creating your own structs
SCORE: 9/12
Computed properties
SCORE: 8/12
Property observers
SCORE: 8/12
Methods
SCORE: 9/12
Mutating methods
SCORE: 8/12
Properties and methods of strings
SCORE: 5/6
Properties and methods of arrays
SCORE: 9/12

## Day9

Initializers
SCORE: 9/12
Referring to the current instance
SCORE: 8/12
Lazy properties
SCORE: 6/6
Static properties and methods
SCORE: 9/12
Access control
SCORE: 7/12
Structs: Summary
SCORE: 5/6

## Day10


Classes
Creating your own classes
SCORE: 9/12
Class inheritance
SCORE: 9/12
Overriding methods
SCORE: 6/12
Final classes
SCORE: 12/12
Copying objects
SCORE: 10/12
Deinitializers
SCORE: 10/12
Mutability
SCORE: 9/12
Classes: Summary
SCORE: 5/6

## Day11


Protocols
SCORE: 12/12
Protocol inheritance
SCORE: 9/12
Extensions
SCORE: 7/12
Protocol extensions
SCORE: 10/12
Protocol-oriented programming
SCORE: 6/6
Protocols and extensions: Summary
SCORE: 8/12

## Day12

Optionals
Handling missing data
SCORE: 6/6
Unwrapping optionals
SCORE: 11/12
Unwrapping with guard
SCORE: 11/12
Force unwrapping
SCORE: 5/6
Implicitly unwrapped optionals
SCORE: 6/6
Nil coalescing
SCORE: 11/12
Optional chaining
SCORE: 8/12
Optional try
SCORE: 5/6
Failable initializers
SCORE: 10/12
Typecasting
SCORE: 7/12
Optionals: Summary
SCORE: 10/12

## Day13

Variables and constants
Types of Data
Operators
String interpolation
Arrays
Dictionaries
Conditional statements
Loops
Switch case

## Day14

Functions
Optionals
Optional chaining
Enumerations
Structs
Classes

## Day15

Properties
Static properties and methods
Access control
Polymorphism and typecasting
Closures

## Day16

WeSplit: Introduction
Understanding the basic structure of a SwiftUI app
Creating a form
Adding a navigation bar
Modifying program state
Binding state to user interface controls
Creating views in a loop

## Day17

Reading text from the user with TextField
Creating pickers in a form
Adding a segmented control for tip percentages
Calculating the total per person

## Day18

WeSplit: Wrap up
Review for Project 1: WeSplit

## Day19 (Chellange1)

## Day20

Guess the Flag: Introduction
Using stacks to arrange views
Colors and frames
Gradients
Buttons and images
Showing alert messages

## Day21

Stacking up buttons
Showing the player’s score with an alert
Styling our flags

## Day22

Guess the Flag: Wrap up
Review for Project 2: Guess the Flag

## Day23 

Views and modifiers: Introduction
Why does SwiftUI use structs for views?
What is behind the main SwiftUI view?
Why modifier order matters
Why does SwiftUI use “some View” for its view type?
Conditional modifiers
Environment modifiers
Views as properties
View composition
Custom modifiers
Custom containers

## Day24

Views and modifiers: Wrap up
Review for Project 3: Views and Modifiers

## Day25

Challenge2

## Day26

BetterRest: Introduction
Entering numbers with Stepper
Selecting dates and times with DatePicker
Working with dates
Training a model with Create ML

## Day27

Building a basic layout
Connecting SwiftUI to Core ML
Cleaning up the user interface

## Day28

BetterRest: Wrap up
Review for Project 4: BetterRest

## Day29

Word Scramble: Introduction
Introducing List, your best friend
Loading resources from your app bundle
Working with strings

## Day30

Adding to a list of words
Running code when our app launches
Validating words with UITextChecker

## Day31 

Word Scramble: Wrap up
Review for Project 5: Word Scramble

## Day32

Animation: Introduction
Creating implicit animations
Customizing animations in SwiftUI
Animating bindings
Creating explicit animations

## Day33

Controlling the animation stack
Animating gestures
Showing and hiding views with transitions
Building custom transitions using ViewModifier

## Day34

Animation: Wrap up
Review for Project 6: Animation

## Day35

Challenge3

## Day36

iExpense: Introduction
Why @State only works with structs
Sharing SwiftUI state with @ObservedObject
Showing and hiding views
Deleting items using onDelete()
Storing user settings with UserDefaults
Archiving Swift objects with Codable

## Day37

Building a list we can delete from
Working with Identifiable items in SwiftUI
Sharing an observed object with a new view
Making changes permanent with UserDefaults
Final polish

## Day38 

iExpense: Wrap up
Review for Project 7: iExpense

## Day39

Moonshot: Introduction
Resizing images to fit the screen using GeometryReader
How ScrollView lets us work with scrolling data
Pushing new views onto the stack using NavigationLink
Working with hierarchical Codable data

## Day40

Loading a specific kind of Codable data
Using generics to load any kind of Codable data
Formatting our mission view

## Day41

Showing mission details with ScrollView and GeometryReader
Merging Codable structs using first(where:)
Fixing problems with buttonStyle() and layoutPriority()

## Day42 

Moonshot: Wrap up
Review for Project 8: Moonshot

## Day43

Drawing: Introduction
Creating custom paths with SwiftUI
Paths vs shapes in SwiftUI
Adding strokeBorder() support with InsettableShape

## Day44

Transforming shapes using CGAffineTransform and even-odd fills
Creative borders and fills using ImagePaint
Enabling high-performance Metal rendering with drawingGroup()

## Day45

Special effects in SwiftUI: blurs, blending, and more
Animating simple shapes with animatableData
Animating complex shapes with AnimatablePair

## Day46

Drawing: Wrap up
Review for Project 9: Drawing

## Day47 

Challenge4

## Day48

Day 48 – Expanding your horizons

## Day49

Cupcake Corner: Introduction
Adding Codable conformance for @Published properties
Sending and receiving Codable data with URLSession and SwiftUI
Validating and disabling forms

## Day50

Taking basic order details
Checking for a valid address
Preparing for checkout

## Day51

Encoding an ObservableObject class
Sending and receiving orders over the internet

## Day52 

Cupcake Corner: Wrap up
Review for Project 10: Cupcake Corner

## Day53

Bookworm: Introduction
Creating a custom component with @Binding
Using size classes with AnyView type erasure
How to combine Core Data and SwiftUI

## Day54

Creating books with Core Data
Adding a custom star rating component
Building a list with @FetchRequest

## Day55

Showing book details
Sorting fetch requests with NSSortDescriptor
Deleting from a Core Data fetch request
Using an alert to pop a NavigationLink programmatically

## Day56

Bookworm: Wrap up
Review for Project 11: Bookworm

## Day57

Core Data: Introduction
Why does \.self work for ForEach?
Creating NSManagedObject subclasses
Conditional saving of NSManagedObjectContext
Ensuring Core Data objects are unique using constraints

## Day58

Filtering @FetchRequest using NSPredicate
Dynamically filtering @FetchRequest with SwiftUI
One-to-many relationships with Core Data, SwiftUI, and @FetchRequest

## Day59

Core Data: Wrap up
Review for Project 12: Core Data

## Challenge5

## ChallengeB

## Day62

Instafilter: Introduction
How property wrappers become structs
Creating custom bindings in SwiftUI
Showing multiple options with ActionSheet

## Day63

Integrating Core Image with SwiftUI
Wrapping a UIViewController in a SwiftUI view

## Day64

Using coordinators to manage SwiftUI view controllers
How to save images to the user’s photo library

## Day65

Building our basic UI
Importing an image into SwiftUI using UIImagePickerController
Basic image filtering using Core Image

## Day66

Customizing our filter using ActionSheet
Saving the filtered image using UIImageWriteToSavedPhotosAlbum()

## Day67

Instafilter: Wrap up
Review for Project 13: Instafilter
